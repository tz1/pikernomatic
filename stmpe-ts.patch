diff --git a/drivers/input/touchscreen/stmpe-ts.c b/drivers/input/touchscreen/stmpe-ts.c
index 59e81b0..df282d4 100644
--- a/drivers/input/touchscreen/stmpe-ts.c
+++ b/drivers/input/touchscreen/stmpe-ts.c
@@ -122,6 +122,27 @@ static void stmpe_work(struct work_struct *work)
 	input_report_abs(ts->idev, ABS_PRESSURE, 0);
 	input_report_key(ts->idev, BTN_TOUCH, 0);
 	input_sync(ts->idev);
+
+	/*
+	 * Sometimes the FIFO_TH interrupt flag is not cleared.
+	 * This prevents the controller from generating a new interrupt.
+	 * It's not enough to clear the flag, re-enabling the touchscreen
+	 * controller is also necessary.
+	 * If an IRQ happens while in this function, FIFO_TH is set, but it
+	 * doesn't indicate a hang. We reset anyway since the consequence is
+	 * losing one data point.
+	 */
+	if (int_sta & 0b00000010) {
+		stmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,
+				STMPE_TSC_CTRL_TSC_EN, 0);
+		stmpe_reg_write(ts->stmpe, STMPE_REG_INT_STA, 0b00000010);
+		__stmpe_reset_fifo(ts->stmpe);
+		stmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,
+				STMPE_TSC_CTRL_TSC_EN, STMPE_TSC_CTRL_TSC_EN);
+		dev_info(ts->dev,
+				"cleared interrupt flag FIFO_TH, INT_STA: 0x%02X -> 0x%02X\n",
+				int_sta, stmpe_reg_read(ts->stmpe, STMPE_REG_INT_STA));
+	}
 }
 
 static irqreturn_t stmpe_ts_handler(int irq, void *data)
